import{R as E}from"./react-DLE0P_Nq.js";const T=o=>{let i;const e=new Set,r=(d,s)=>{const y=typeof d=="function"?d(i):d;if(!Object.is(y,i)){const m=i;i=s??(typeof y!="object"||y===null)?y:Object.assign({},i,y),e.forEach(f=>f(i,m))}},n=()=>i,u={setState:r,getState:n,getInitialState:()=>S,subscribe:d=>(e.add(d),()=>e.delete(d))},S=i=o(r,n,u);return u},D=o=>o?T(o):T,N=o=>o;function j(o,i=N){const e=E.useSyncExternalStore(o.subscribe,()=>i(o.getState()),()=>i(o.getInitialState()));return E.useDebugValue(e),e}const J=o=>{const i=D(o),e=r=>j(i,r);return Object.assign(e,i),e},F=o=>J,R={BASE_URL:"/meiliAdmin/riccox",DEV:!1,MODE:"production",PROD:!0,SSR:!1},I=new Map,_=o=>{const i=I.get(o);return i?Object.fromEntries(Object.entries(i.stores).map(([e,r])=>[e,r.getState()])):{}},k=(o,i,e)=>{if(o===void 0)return{type:"untracked",connection:i.connect(e)};const r=I.get(e.name);if(r)return{type:"tracked",store:o,...r};const n={connection:i.connect(e),stores:{}};return I.set(e.name,n),{type:"tracked",store:o,...n}},A=(o,i={})=>(e,r,n)=>{const{enabled:l,anonymousActionType:p,store:u,...S}=i;let d;try{d=(l??(R?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!d)return o(e,r,n);const{connection:s,...y}=k(u,d,S);let m=!0;n.setState=(t,v,a)=>{const c=e(t,v);if(!m)return c;const h=a===void 0?{type:p||"anonymous"}:typeof a=="string"?{type:a}:a;return u===void 0?(s==null||s.send(h,r()),c):(s==null||s.send({...h,type:`${u}/${h.type}`},{..._(S.name),[u]:n.getState()}),c)};const f=(...t)=>{const v=m;m=!1,e(...t),m=v},g=o(n.setState,r,n);if(y.type==="untracked"?s==null||s.init(g):(y.stores[y.store]=n,s==null||s.init(Object.fromEntries(Object.entries(y.stores).map(([t,v])=>[t,t===y.store?g:v.getState()])))),n.dispatchFromDevtools&&typeof n.dispatch=="function"){let t=!1;const v=n.dispatch;n.dispatch=(...a)=>{(R?"production":void 0)!=="production"&&a[0].type==="__setState"&&!t&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),t=!0),v(...a)}}return s.subscribe(t=>{var v;switch(t.type){case"ACTION":if(typeof t.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return b(t.payload,a=>{if(a.type==="__setState"){if(u===void 0){f(a.state);return}Object.keys(a.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const c=a.state[u];if(c==null)return;JSON.stringify(n.getState())!==JSON.stringify(c)&&f(c);return}n.dispatchFromDevtools&&typeof n.dispatch=="function"&&n.dispatch(a)});case"DISPATCH":switch(t.payload.type){case"RESET":return f(g),u===void 0?s==null?void 0:s.init(n.getState()):s==null?void 0:s.init(_(S.name));case"COMMIT":if(u===void 0){s==null||s.init(n.getState());return}return s==null?void 0:s.init(_(S.name));case"ROLLBACK":return b(t.state,a=>{if(u===void 0){f(a),s==null||s.init(n.getState());return}f(a[u]),s==null||s.init(_(S.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return b(t.state,a=>{if(u===void 0){f(a);return}JSON.stringify(n.getState())!==JSON.stringify(a[u])&&f(a[u])});case"IMPORT_STATE":{const{nextLiftedState:a}=t.payload,c=(v=a.computedStates.slice(-1)[0])==null?void 0:v.state;if(!c)return;f(u===void 0?c:c[u]),s==null||s.send(null,a);return}case"PAUSE_RECORDING":return m=!m}return}}),g},H=A,b=(o,i)=>{let e;try{e=JSON.parse(o)}catch(r){console.error("[zustand devtools middleware] Could not parse the received json",r)}e!==void 0&&i(e)};function x(o,i){let e;try{e=o()}catch{return}return{getItem:n=>{var l;const p=S=>S===null?null:JSON.parse(S,void 0),u=(l=e.getItem(n))!=null?l:null;return u instanceof Promise?u.then(p):p(u)},setItem:(n,l)=>e.setItem(n,JSON.stringify(l,void 0)),removeItem:n=>e.removeItem(n)}}const O=o=>i=>{try{const e=o(i);return e instanceof Promise?e:{then(r){return O(r)(e)},catch(r){return this}}}catch(e){return{then(r){return this},catch(r){return O(r)(e)}}}},P=(o,i)=>(e,r,n)=>{let l={storage:x(()=>localStorage),partialize:t=>t,version:0,merge:(t,v)=>({...v,...t}),...i},p=!1;const u=new Set,S=new Set;let d=l.storage;if(!d)return o((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${l.name}', the given storage is currently unavailable.`),e(...t)},r,n);const s=()=>{const t=l.partialize({...r()});return d.setItem(l.name,{state:t,version:l.version})},y=n.setState;n.setState=(t,v)=>{y(t,v),s()};const m=o((...t)=>{e(...t),s()},r,n);n.getInitialState=()=>m;let f;const g=()=>{var t,v;if(!d)return;p=!1,u.forEach(c=>{var h;return c((h=r())!=null?h:m)});const a=((v=l.onRehydrateStorage)==null?void 0:v.call(l,(t=r())!=null?t:m))||void 0;return O(d.getItem.bind(d))(l.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==l.version){if(l.migrate)return[!0,l.migrate(c.state,c.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,c.state];return[!1,void 0]}).then(c=>{var h;const[w,C]=c;if(f=l.merge(C,(h=r())!=null?h:m),e(f,!0),w)return s()}).then(()=>{a==null||a(f,void 0),f=r(),p=!0,S.forEach(c=>c(f))}).catch(c=>{a==null||a(void 0,c)})};return n.persist={setOptions:t=>{l={...l,...t},t.storage&&(d=t.storage)},clearStorage:()=>{d==null||d.removeItem(l.name)},getOptions:()=>l,rehydrate:()=>g(),hasHydrated:()=>p,onHydrate:t=>(u.add(t),()=>{u.delete(t)}),onFinishHydration:t=>(S.add(t),()=>{S.delete(t)})},l.skipHydration||g(),f||m},L=P;export{F as c,H as d,L as p};
